I have problem in this function try to fix it if in config file of my server 
i don't have location name like /hello or something like that and I do 
localhost:1024/hello/ he must not give me not found and he must give me the default_root and remove /hello and try to server like this 
and if I have like in url: localhost:1024/hello/index.html I must replace /hello with the default_root
to become like /nfs/home/destop/webserv/var/www/html and join the default_root with the index.html to become 
/nfs/home/destop/webserv/var/www/html/index.html and try to serve and /hello is just example it's can be /hhhh
or localhost:1024/lllsldjsljljdfs/index.php ... and so become if I have default_root= /nfs/home/destop/webserv/var/www/html must become /nfs/home/destop/webserv/var/www/html/index.php and try to serve it 

#include "../include/mainHeader.hpp"
#include <fcntl.h>
#include <fstream>

std::string getMimeType(std::string& filePath)
{
    std::map<std::string, std::string> mimeTypes;
    mimeTypes[".html"] = "text/html";
    mimeTypes[".css"] = "text/css";
    mimeTypes[".js"] = "application/javascript";
    mimeTypes[".json"] = "application/json";
    mimeTypes[".png"] = "image/png";
    mimeTypes[".jpg"] = "image/jpeg";
    mimeTypes[".jpeg"] = "image/jpeg";
    mimeTypes[".gif"] = "image/gif";
    mimeTypes[".svg"] = "image/svg+xml";
    mimeTypes[".xml"] = "application/xml";
    mimeTypes[".pdf"] = "application/pdf";
    mimeTypes[".txt"] = "text/plain";
    mimeTypes[".mp3"] = "audio/mpeg";
    mimeTypes[".mp4"] = "video/mp4";
    size_t dotPos = filePath.rfind('.');
    if (dotPos != std::string::npos)
    {
        std::string extension = filePath.substr(dotPos);
        if (mimeTypes.find(extension) != mimeTypes.end())
            return mimeTypes[extension];
    }
    return "text/plain";
}

bool fileExists( std::string& path) {
    struct stat buffer;
    return (stat(path.c_str(), &buffer) == 0);
}

bool hasReadPermission(const std::string& path) {
    return (access(path.c_str(), R_OK) == 0);
}

// bool fileExists(std::string& filePath)
// {
//     std::ifstream file(filePath.c_str());
//     return file.good();
// }

// std::string mapUriToFilePath( std::string& uri,  location& locConfig)
// {
//     try
//     {
//         std::string rootPath = locConfig.root.at("root"); // Use .at() for const map
//         std::string filePath = rootPath; // Start constructing the file path from the root
//         std::string locPath = locConfig.directory.at("location");
//         std::string pathSuffix;
//         std::string fullPath;
//         if (uri.find(locPath) == 0)
//             pathSuffix = uri.substr(locPath.length());
//         else
//             pathSuffix = uri;
//         if (pathSuffix.empty() || pathSuffix[pathSuffix.size() - 1] == '/')
//         {
//             std::istringstream iss(locConfig.index.at("index")); // Use .at() here as well
//             std::string indexFile;
//             while (std::getline(iss, indexFile, ' '))
//             {
//                 fullPath = filePath + (pathSuffix[pathSuffix.length() - 1] == '/' ? pathSuffix : pathSuffix + "/") + indexFile;
//                 if (fileExists(fullPath))
//                     return fullPath; // Found an index file, return its path
//             }
//             return fullPath;
//             // Optional: Handle case when no index file is found...
//         }
//     else
//     {
//         // If the pathSuffix is not empty and does not end with '/', directly append it to filePath.
//         if (filePath[filePath.length() -1 ] != '/')
//             filePath += "/";
//         filePath += pathSuffix;
//         if (fileExists(filePath))
//             return filePath;
//         return filePath;
//         // Handle file not found if necessary.
//     }
//     }
//     catch (const std::out_of_range& e)
//     {
//         // Handle the case where a key does not exist in the map
//         std::cerr << "Key not found in configuration: " << e.what() << '\n';
//         // Handle error, possibly return a default value or error indicator
//     }
//     return ""; // Placeholder return to satisfy all control paths
// }



std::string mapUriToFilePath(std::string uri, const location& locConfig, const std::string& defaultRoot, bool& found)
{
    std::string rootPath = (found) ? locConfig.root.at("root") : defaultRoot;
    std::string locPath = locConfig.directory.at("location");
    uri = uri.substr(locPath.length());
    std::string filePath = rootPath + uri;
    std::cout << "------------>: " << locConfig.directory.at("location") << std::endl;
    std::cout << "Root: ------------>: " << rootPath << '\n';
    std::cout << "Root: ------------>: " << filePath << '\n';
    if (isDirectory(filePath))
    {
        // Attempt to find an index file within the directory
        std::istringstream indices(locConfig.index.at("index"));
        std::string indexFile;
        while (std::getline(indices, indexFile, ' '))
        {
            std::string potentialPath = filePath + "/" + indexFile;
            if (fileExists(potentialPath) && hasReadPermission(potentialPath))
            {
                return potentialPath;
            }
        }
        // If no index file was found, generate directory listing or return "404"
        if (locConfig.autoindex.at("autoindex") == "on")
        {
            // Generate directory listing HTML
            return (filePath);
        }
        std::cout << "=========================================================\n";
        return "404"; // No index file found and autoindex is off
    }
    else if (fileExists(filePath) && hasReadPermission(filePath)) {
        // File exists and has read permission
        return filePath;
    }
    else
    {
        // File does not exist or no read permission
        return "404";
    }
}


location findRouteConfig(std::string& uri, const informations& serverConfig, bool& defaultFound)
{
    size_t longestMatch = 0;
    location defaultLocation;

    // Attempt to find a matching location configuration
    for (size_t i = 0; i < serverConfig.locationsInfo.size(); ++i)
    {
        const location& loc = serverConfig.locationsInfo[i];
        const std::string& locPath = loc.directory.find("location") != loc.directory.end() ? loc.directory.at("location") : "";
        if (uri.compare(0, locPath.length(), locPath) == 0 && locPath.length() > longestMatch) {
            longestMatch = locPath.length();
            defaultLocation = loc;
        }
        if (locPath == "/") {
            defaultFound = true; // Mark that we've found a default ("/") location
        }
    }

    // Use the first location as the default if no "/" location is defined
    if (!defaultFound && !serverConfig.locationsInfo.empty()) {
        defaultLocation = serverConfig.locationsInfo[0];
    }

    // Check if we have a global defaultRoot defined and no location matched
    if (serverConfig.defaultRoot.find("default_root") != serverConfig.defaultRoot.end() && longestMatch == 0) {
        defaultLocation.root["root"] = serverConfig.defaultRoot.at("default_root");
    }

    return defaultLocation;
}

// location findRouteConfig(std::string& uri,const informations& serverConfig)
// {
//     for (size_t i = 0; i < serverConfig.locationsInfo.size(); ++i)
//     {
//         location loc = serverConfig.locationsInfo[i];
//         std::map<std::string, std::string>::const_iterator it = loc.directory.find("location");
//         if (it != loc.directory.end())
//         {
//             std::string locPath = it->second;
//             std::cout << "===========: " << locPath << std::endl;
//             if (uri.compare(0, locPath.length(), locPath) == 0)
//             {
//                 std::cout << "===============>>><<<<<<>>>>: " << loc.directory.at("location") << std::endl;
//                 return loc;
//             }
//         }
//     }
//     location loc = serverConfig.locationsInfo[0];
//     return loc;
// }


bool isRegularFile(const std::string& path)
{
    struct stat statbuf;
    if (stat(path.c_str(), &statbuf) != 0)
        return false;
    return S_ISREG(statbuf.st_mode);
}

bool isDirectory(const std::string& path)
{
    struct stat statbuf;
    if (stat(path.c_str(), &statbuf) != 0)
        return false;
    return S_ISDIR(statbuf.st_mode);
}
std::string generateDirectoryListing(const std::string& path)
{
    DIR *dir;
    struct dirent *ent;
    std::ostringstream html;
    std::cout << "path dire: " << path << std::endl;
    html << "<html><head><title>Index of " << path << "</title></head><body>";
    html << "<h1>Index of " << path << "</h1><hr><pre>";

    dir = opendir(path.c_str());
    if (dir != NULL)
    {
        std::cout << "dir: " << dir << std::endl;
        while ((ent = readdir(dir)) != NULL)
            html << "<a href='" << ent->d_name << "'>" << ent->d_name << "</a><br>";
        closedir(dir);
    }
    else
        html << "Cannot access directory.";
    html << "</pre><hr></body></html>";
    return html.str();
}

std::string to_string(int value)
{
    std::ostringstream os;
    os << value;
    return os.str();
}

void connection::handleRequestGET(int clientSocket, Request& request,const informations& serverConfig)
{
    bool foundLocation = false;
    location routeConfig = findRouteConfig(request.headers["uri"], serverConfig, foundLocation);
    if (routeConfig.allowed_methodes["allowed_methodes"].find("GET") == std::string::npos)
    {
        serveErrorPage(clientSocket, 405, serverConfig);
        return;
    }
    std::map<std::string, std::string>::iterator it = routeConfig.Return.find("return");
    if ( it != routeConfig.Return.end() && !it->second.empty())
    {
        std::string redirectURL = it->second; // URL to redirect to
        std::cout << "==========================>: RedirectURL: " << redirectURL << std::endl;
        std::string responseD = "HTTP/1.1 301 Moved Permanently\r\n";
        responseD += "Location: " + redirectURL + "\r\n";
        responseD += "Content-Length: 0\r\n";
        responseD += "Connection: close\r\n\r\n";
        response responseData;
        responseData.setResponseHeader(responseD);
        request.storeHeader = true;
        Response[clientSocket] = responseData;
        return;
    }
    else
    {
        std::map<std::string, std::string>::const_iterator it = routeConfig.directory.find("location");
        std::cout << "Location test: ++++++++========>: " << it->second << std::endl;
        std::string filePath2 = mapUriToFilePath(request.headers["uri"], routeConfig, serverConfig.defaultRoot.at("default_root"), foundLocation);
        std::cout << "===========>: " << filePath2 << std::endl;
        std::string filePath = filePath2;
        // if (routeConfig.cgi.at("cgi") == "on")
        // {
        //     //work on cgi now you can use anything you want ba3bab3a3bab3abb3abab3aba3b
        // }

            // Check if the file exists and has read permission
    if (!fileExists(filePath)) {
        serveErrorPage(clientSocket, 404, serverConfig); // File not found
        return;
    }
    if (!hasReadPermission(filePath)) {
        serveErrorPage(clientSocket, 403, serverConfig); // Forbidden
        return;
    }
        // if (!access(filePath.c_str(), F_OK))
        // {
        //     if (access(filePath.c_str(), R_OK))
        //     {
        //         serveErrorPage(clientSocket, 403, serverConfig);
        //         return;
        //     }
        // }
        // else
        // {
        //     serveErrorPage(clientSocket, 404, serverConfig); // Not Found
        //     return;
        // }
        // if (!fileExists(filePath))
        // {
        //     std::cout << "===========================================><><><>\n";
        //         serveErrorPage(clientSocket, 404, serverConfig);
        //         return;
        // }
        std::cout << "=======>: path: " << filePath << std::endl;
        std::string responseD;
        if (isDirectory(filePath))
        {
            std::vector<location>::const_iterator it = serverConfig.locationsInfo.begin();
            std::string check = request.headers["uri"] + it->index.at("index");
            std::map<std::string, std::string>::iterator autoindexIt = routeConfig.autoindex.find("autoindex");
            if (isRegularFile(check))
            {
                responseD = "HTTP/1.1 301 OK\r\n";
                responseD += "Location: " + check + " \r\n";
            }
            else if (autoindexIt != routeConfig.autoindex.end() && autoindexIt->second == "on")
            {
                std::string directoryContent = generateDirectoryListing(filePath);
                std::cout << directoryContent << std::endl;
                responseD = "HTTP/1.1 200 OK\r\n";
                responseD += "Content-Type: text/html\r\n";
                responseD += "Content-Length: " + to_string(directoryContent.size()) + "\r\n";
                
                responseD += "\r\n";
                responseD += directoryContent;
            }
        }
        else
        {
            responseD = "HTTP/1.1 200 OK\r\n";
            responseD += "Content-Type: " + getMimeType(filePath) + "\r\n";
            // std::cout << "check if this correct" << std::endl;;
            /* -------------- yachaab code start ----------------- */
            // std::fstream file;
            // file.open( "./media/video/morpho.mp4", std::fstream::binary | std::fstream::ate | std::fstream::in );
            // size_t size = file.tellg();
            // file.close();
            // // std::cout << "size: " << size << std::endl;
            // responseD += "Content-Length: " + to_string( size ) + "\r\n";
            // std::cout << "MIME TYPE: " << getMimeType(filePath) << std::endl;
            // std::cout << "content length: " << xnxx << std::endl;
            /*-------------- yachaab code ended -----------------*/
        }
        // if (request.flagRespons == 0)
        // {
            response responseData;

            responseData.filePath = filePath;
            responseData.setResponseHeader(responseD);
            request.storeHeader = true;
            Response[clientSocket] = responseData;

    }
}

